#!/bin/bash

# Default cron schedule, if not provided via environment variable
CRON_SCHEDULE="${CRON_SCHEDULE:-"5 9 * * *"}"
LOG_DIR_PATH="${LOG_DIR:-/app/log}" # Ensure LOG_DIR_PATH is available

echo "Using CRON_SCHEDULE: ${CRON_SCHEDULE}"
echo "Logging to directory: ${LOG_DIR_PATH}"

# Remove existing crontab to avoid duplicates if container restarts
# Using 'crontab -r' can sometimes fail if no crontab exists, so redirect stderr to /dev/null
crontab -r 2>/dev/null || true

# --- Create a file to store dynamic environment variables for the cron job ---
# This file will be sourced by the backup.sh script when run by cron.
# We need to capture ALL relevant environment variables that backup.sh might need.
# This list should include ALL env vars that you pass to the Docker container
# for backup configuration (e.g., OPWD_*, S3_*, TARGET_*, AGE_*, etc.)
# For demonstration, I'll include the most common ones.
# IMPORTANT: Manually add any other environment variables your backup.sh uses!
# Example: If you pass -e OPWD_URL="http://vault" to docker run, it MUST be listed here.

ENV_FILE="/etc/cron.d/backup_env.sh" # Or /app/backup_env.sh if you prefer /app
mkdir -p "$(dirname "$ENV_FILE")" # Ensure directory exists
chmod 700 "$(dirname "$ENV_FILE")" # Secure the directory

cat <<EOF > "$ENV_FILE"
#!/bin/bash
# This file is dynamically generated by setup_cron.sh
# It contains environment variables for the cron job.

# Core variables
export OPWD_URL="${OPWD_URL:-}"
export OPWD_TOKEN="${OPWD_TOKEN:-}"
export OPWD_VAULT="${OPWD_VAULT:-}"
export OPWD_MONGO_KEY="${OPWD_MONGO_KEY:-}"
export OPWD_CLOUD_KEY="${OPWD_CLOUD_KEY:-}"
export OPWD_LOCAL_KEY="${OPWD_LOCAL_KEY:-}"

# Backup specific variables
export CLOUD_UPLOAD="${CLOUD_UPLOAD:-false}"
export LOCAL_UPLOAD="${LOCAL_UPLOAD:-false}"
export BACKUP_COMPRESS="${BACKUP_COMPRESS:-true}"
export BACKUP_COMPRESS_LEVEL="${BACKUP_COMPRESS_LEVEL:-6}"
export AGE_ENCRYPT="${AGE_ENCRYPT:-false}"
export AGE_PUBLIC_KEY="${AGE_PUBLIC_KEY:-}"
export BACKUP_TIMESTAMP="${BACKUP_TIMESTAMP:-%Y%m%d%H%M%S}"
export BACKUP_ADDITIONAL_PARAMS="${BACKUP_ADDITIONAL_PARAMS:-}"
export LOCAL_S3_SIGNATURE_VERSION="${LOCAL_S3_SIGNATURE_VERSION:-s4}"

# MongoDB specific variables
export TARGET_DB_COLLECTION_PAIRS="${TARGET_DB_COLLECTION_PAIRS:-}"
export TARGET_ALL_DATABASES="${TARGET_ALL_DATABASES:-false}"
export INCLUDE_SYSTEM_DATABASES="${INCLUDE_SYSTEM_DATABASES:-false}"
export TARGET_DATABASE_NAMES="${TARGET_DATABASE_NAMES:-}"

# Logging and runtime variables
export LOG_DIR="${LOG_DIR_PATH}"
export POD_NAME="${POD_NAME:-$(hostname)}"
export NODE_NAME="${NODE_NAME:-unknown}"
export APP_NAME="${APP_NAME:-unknown}"
export TENANT="${TENANT:-unknown}"
export SCRIPT_POST_RUN_SLEEP_SECONDS="${SCRIPT_POST_RUN_SLEEP_SECONDS:-}"

# Set the PATH for the cron job, including /usr/local/bin, go tools, and google-cloud-sdk
export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/lib/go/bin:/app/google-cloud-sdk/bin:/root/.local/bin:${PATH}"

EOF

chmod +x "$ENV_FILE" # Make the environment file executable for sourcing
echo "Created environment file: $ENV_FILE"
cat "$ENV_FILE" # Print its content for verification in logs

# --- Add the cron job ---
# The cron job will first source the environment file, then execute the backup script.
# This ensures all necessary environment variables are set for backup.sh.
# We also redirect stdout and stderr to the log file for proper logging.

CRONTAB_ENTRY="${CRON_SCHEDULE} /bin/bash -c \"source $ENV_FILE && /app/backup.sh >> ${LOG_DIR_PATH}/cron.log 2>&1\""

# Add the cron job to crontab
# Using echo with a here document for clean multi-line injection
cat << EOF | crontab -
# Cron job for MongoDB Backup
${CRONTAB_ENTRY}
EOF

# Verify crontab content
echo "Crontab content after setup:"
crontab -l

echo "Crontab setup complete. Starting cron daemon."
# Start cron in the foreground. This is crucial for Docker containers
# so the container doesn't exit immediately.
exec cron -f
